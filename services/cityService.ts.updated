// Versiune simplificată pentru app
// Lasă backend-ul să gestioneze auto-population

async getCurrentLocationCity(): Promise<LocationInfo | null> {
  try {
    const { status } = await Location.requestForegroundPermissionsAsync();
    if (status !== 'granted') {
      return null;
    }

    const location = await Location.getCurrentPositionAsync({});
    const [reverseGeocode] = await Location.reverseGeocodeAsync({
      latitude: location.coords.latitude,
      longitude: location.coords.longitude,
    });

    if (reverseGeocode?.city) {
      // Caută în DB local
      const cities = await this.searchCities(
        reverseGeocode.city,
        reverseGeocode.isoCountryCode
      );

      if (cities.length > 0) {
        return {
          city: cities[0],
          coordinates: {
            latitude: location.coords.latitude,
            longitude: location.coords.longitude,
          },
        };
      } else {
        // NU salvăm aici - trimitem la backend
        // Backend-ul va salva orașul după ce îl îmbogățește cu date
        return {
          city: {
            id: 'temp-' + Date.now(),
            name: reverseGeocode.city,
            country_code: reverseGeocode.isoCountryCode || 'US',
            country_name: reverseGeocode.country || 'United States',
            // Valori temporare - backend le va actualiza
            lat: location.coords.latitude,
            lng: location.coords.longitude,
            population: 0,
            importance_score: 0.5
          },
          coordinates: {
            latitude: location.coords.latitude,
            longitude: location.coords.longitude,
          },
          isTemporary: true // Flag pentru UI
        };
      }
    }

    return null;
  } catch (error) {
    console.error('Error getting current location:', error);
    return null;
  }
}